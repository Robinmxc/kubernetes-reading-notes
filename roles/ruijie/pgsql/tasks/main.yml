- name: 准备init目录
  tags:
  - config
  file: path="{{ pgsql_init_dir }}" state=directory
  when: '"" != pgsql_init_dir'

- name: 在deploy节点准备目录
  tags:
  - config
  file: path={{ item }} state=directory
  with_items:
  - "{{ yaml_dir }}/pgsql"
  run_once: true
  connection: local

- name: 检查数据库密码是否符合要求
  tags:
  - config
  fail: msg="数据库管理员密码不符合要求，{{ db_pwd_invalid_msg }}"
  when: 'mongodb_auth_mode == "yes" and ( PGSQL_ADMIN_PWD is not search(db_pwd_pattern1) or PGSQL_ADMIN_PWD is not search(db_pwd_pattern2) )'
  connection: local
  run_once: true
 
- name: 准备升级数据的脚本
  template: src="pgsql-init.sh.j2" dest="{{ pgsql_init_dir }}/pgsql-init.sh"

- name: 设置升级脚本文件执行权限
  file: name="{{ item }}" mode=0700
  with_items:
  - "{{ pgsql_init_dir }}/pgsql-init.sh"


- name: 准备pgsql的部署文件
  tags:
  - config
  vars:
    pgsql_node_name: "{{ hostvars[groups.pgsql[0]]['PG_NODE_NAME'] }}"
    pgsql_node_ip: "{{ groups.pgsql[0] }}"
    deploy_conf: '{{ pgsql_deploy_conf }}'
  template: src=pgsql.yml.j2 dest={{ yaml_dir }}/pgsql/pgsql.yml
  run_once: true
  connection: local

- name: 获取已下载离线镜像信息
  command: "ls {{ base_dir }}/down"
  register: download_info
  connection: local
  run_once: true

- name: 获取所有已经创建的POD信息
  command: "{{ bin_dir }}/kubectl get pod -n {{ APP_NAMESPACE }}"
  register: pod_info
  run_once: true
  connection: local

- name: 部署pgsql
  when: '"postgresql" not in pod_info.stdout'
  block:
    - name: 分发镜像文件
      copy: src={{ base_dir }}/down/{{ pgsql_offline }} dest=/opt/kube/images/{{ pgsql_offline }}
      when: '"allinone" != DEPLOY_MODE and pgsql_offline in download_info.stdout'

    - name: 获取docker已加载的镜像信息
      command: "docker images --format ''{{ '{{' }}.Repository{{ '}}' }}:{{ '{{' }}.Tag{{ '}}' }}''"
      register: imgages_info

    - name: 导入镜像
      when: '"postgresql" not in imgages_info.stdout'
      vars:
        img_dir: '{% if "allinone" == DEPLOY_MODE %}{{ img_download_dir }}{% else %}{{ img_copy_dir }}{% endif %}'
      shell: "{{ bin_dir }}/docker load -i {{ img_dir }}/{{ pgsql_offline }}"

    - name: 部署pgsql
      shell: "{{ bin_dir }}/kubectl apply -f {{ yaml_dir }}/pgsql/pgsql.yml"
      connection: local
      run_once: true

    - name: 轮询等待pgsql运行
      shell: "{{ bin_dir }}/kubectl get pod -n {{ APP_NAMESPACE }} | grep 'postgresql' | awk '{print $3}'"
      register: pod_status
      until: pod_status.stdout == "Running"
      connection: local
      run_once: true
      retries: 12
      delay: 5
      ignore_errors: true

    - name: 暂停15秒等待pgsql启动完成
      wait_for: timeout=15

    - name: 压缩数据初始化脚本
      archive:
        path: "{{ KAD_PACKAGE_DIR }}/db/"
        dest: "{{ temp_dir }}/{{ KAD_PACKAGE_NAME }}-data.tgz"
      connection: local
      run_once: true

    - name: 复制数据初始化脚本
      copy: src="{{ temp_dir }}/{{ KAD_PACKAGE_NAME }}-data.tgz" dest="{{ pgsql_init_dir }}/data.tgz"

    - name: 解压数据初始化脚本
      unarchive:
        src: "{{ pgsql_init_dir }}/data.tgz"
        dest: "{{ pgsql_init_dir }}/"
        remote_src: yes

    - name: 获取pgsql POD 名称
      shell: "{{ bin_dir }}/kubectl get pod -n {{ APP_NAMESPACE }} -o custom-columns=NAME:.metadata.name | grep postgresql"
      register: shell_result
      connection: local
      run_once: true

    - name: 设置pgsql shell
      set_fact:
        pgsql_pod_name: "{{ shell_result.stdout }}"
        pgsql_pod_shell: "{{ bin_dir }}/kubectl exec -n {{ APP_NAMESPACE }} {{ shell_result.stdout }} -- psql -U postgres "
      connection: local
      run_once: true
      
    - name: 查询pgsql 是否已初始化
      shell: '{{ pgsql_pod_shell }} --c "\l"'
      register: table_result
      connection: local
      run_once: true

    - name: 创建quartz数据库
      shell: '{{ pgsql_pod_shell }} --c "CREATE DATABASE quartz"'
      when: '"quartz" not in table_result.stdout'
      register: create_result
      failed_when: 'create_result.stdout is not search("CREATE DATABASE")'
      connection: local

    - name: 初始化quartz数据
      shell: '{{ pgsql_pod_shell }} -d quartz -f /ruijie/init/sourceid/init.sql'
      when: '"quartz" not in table_result.stdout'
      register: init_result
      failed_when: 'init_result.stdout is search("command terminated")'
      connection: local